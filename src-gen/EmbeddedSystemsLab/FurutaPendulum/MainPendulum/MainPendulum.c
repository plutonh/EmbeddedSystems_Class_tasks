// Code generated by the Lingua Franca compiler from:
// file://home/plutonh/project/EmbeddedSystemsLab/FurutaPendulum/MainPendulum.lf
#define LOG_LEVEL 2
#define TARGET_FILES_DIRECTORY "/home/plutonh/project/src-gen/EmbeddedSystemsLab/FurutaPendulum/MainPendulum"
#include "include/ctarget/ctarget.h"
#include "core/threaded/reactor_threaded.c"
#include "core/threaded/scheduler.h"
#include "core/mixed_radix.h"
int main(int argc, char* argv[]) {
    return lf_reactor_c_main(argc, argv);
}
void _lf_set_default_command_line_options() {}
// =============== START reactor class PendulumSimulation
// *********** From the preamble, verbatim:
#include <math.h>
    
// *********** End of preamble.
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_u_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_d_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_theta_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_d_theta_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_phi_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumsimulation_d_phi_t;
typedef struct {
    struct self_base_t base;
    double initial_theta;
    interval_t sample_period;
    double g;
    double alpha;
    double beta;
    double gamma;
    double epsilon;
    double* x;
    bool first;
    double latest_u;
    pendulumsimulation_u_t* _lf_u;
    // width of -2 indicates that it is not a multiport.
    int _lf_u_width;
    // Default input (in case it does not get connected)
    pendulumsimulation_u_t _lf_default__u;
    pendulumsimulation_d_t* _lf_d;
    // width of -2 indicates that it is not a multiport.
    int _lf_d_width;
    // Default input (in case it does not get connected)
    pendulumsimulation_d_t _lf_default__d;
    pendulumsimulation_theta_t _lf_theta;
    int _lf_theta_width;
    pendulumsimulation_d_theta_t _lf_d_theta;
    int _lf_d_theta_width;
    pendulumsimulation_phi_t _lf_phi;
    int _lf_phi_width;
    pendulumsimulation_d_phi_t _lf_d_phi;
    int _lf_d_phi_width;
    reaction_t _lf__reaction_0;
    reaction_t _lf__reaction_1;
    reaction_t _lf__reaction_2;
    trigger_t _lf__t;
    reaction_t* _lf__t_reactions[1];
    trigger_t _lf__u;
    reaction_t* _lf__u_reactions[1];
    trigger_t _lf__d;
    reaction_t* _lf__d_reactions[1];
} pendulumsimulation_self_t;
// ***** Start of method declarations.
// ***** End of method declarations.
#include "include/ctarget/set.h"
void pendulumsimulationreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pendulumsimulation_self_t* self = (pendulumsimulation_self_t*)instance_args;
    pendulumsimulation_theta_t* theta = &self->_lf_theta;
    pendulumsimulation_d_theta_t* d_theta = &self->_lf_d_theta;
    pendulumsimulation_phi_t* phi = &self->_lf_phi;
    pendulumsimulation_d_phi_t* d_phi = &self->_lf_d_phi;
    #pragma GCC diagnostic pop
    if (!self->first) {
        // Update the state.
        double x0_dot = self->x[1];
        double x1_dot = 1.0/(
                self->alpha * self->beta
                + pow(self->alpha * sin(self->x[0]), 2.0)
                - pow(self->gamma * cos(self->x[0]), 2.0)
            ) * (
                (
                    self->alpha
                    * self->beta
                    + pow(self->alpha * sin(self->x[0]), 2.0)
                )
                * pow(self->x[3], 2.0)
                * sin(self->x[0])
                * cos(self->x[0])
            -
                pow(self->gamma * self->x[1], 2.0)
                * sin(self->x[0])
                * cos(self->x[0])
            +
                2.0
                * self->alpha
                * self->gamma\
                * self->x[1]
                * self->x[3]
                * sin(self->x[0])
                * pow(cos(self->x[0]), 2.0)
            -
                self->gamma
                * cos(self->x[0])
                * self->g
                * self->latest_u
            + 
                (
                    self->alpha 
                    * self->beta 
                    + pow(self->alpha * sin(self->x[0]), 2.0)
                )
                * self->epsilon / self->alpha * sin(self->x[0])
            );
        double x2_dot = self->x[3];
        double x3_dot = (1.0 / (
                self->alpha * self->beta 
                + pow(self->alpha * sin(self->x[0]), 2.0)
                - pow(self->gamma * cos(self->x[0]), 2.0)
            )) * (
                -self->gamma
                * self->alpha
                * pow(self->x[3], 2.0)
                * sin(self->x[0])
                * pow(cos(self->x[1]), 2.0)
            -
                self->gamma
                * self->epsilon
                * sin(self->x[0])
                * cos(self->x[0])
            +
                self->gamma
                * self->alpha
                * pow(self->x[1], 2.0)
                * sin(self->x[0])
            -
                2
                * pow(self->alpha, 2.0)
                * self->x[1]
                * self->x[3]
                * sin(self->x[0])
                * cos(self->x[0])
            +
                self->alpha
                * self->g
                * self->latest_u
            );
        double sample_period = self->sample_period * 1e-9;
        self->x[0] += x0_dot * sample_period;
        self->x[1] += x1_dot * sample_period;
        self->x[2] += x2_dot * sample_period;
        self->x[3] += x3_dot * sample_period;
    } else {
        self->x[0] = self->initial_theta;
        self->first = false;
    }
    // Output the state.
    lf_set(theta, self->x[0]);
    lf_set(d_theta, self->x[1]);
    lf_set(phi, self->x[2]);
    lf_set(d_phi, self->x[3]);
        
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void pendulumsimulationreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pendulumsimulation_self_t* self = (pendulumsimulation_self_t*)instance_args;
    pendulumsimulation_d_t* d = self->_lf_d;
    int d_width = self->_lf_d_width;
    #pragma GCC diagnostic pop
    // NOTE: If the disturbance is coincident with a sample,
    // then it won't have any effect on theta until the next sample.
    // Hence, this reaction needs to be after the previous.
    // NOTE: If the disturbance is in between samples, then
    // we effectively shift the disturbance to be
    // simultaneous with the next sample. A more accurate model
    // would apply the disturbance immediately.
    // The update of the state vector in the reaction below
    // should first be factored out to a method, when methods
    // are implemented in C.
    self->x[1] += d->value;
        
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void pendulumsimulationreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pendulumsimulation_self_t* self = (pendulumsimulation_self_t*)instance_args;
    pendulumsimulation_u_t* u = self->_lf_u;
    int u_width = self->_lf_u_width;
    #pragma GCC diagnostic pop
    self->latest_u = u->value;
        
}
#include "include/ctarget/set_undef.h"
pendulumsimulation_self_t* new_PendulumSimulation() {
    pendulumsimulation_self_t* self = (pendulumsimulation_self_t*)_lf_new_reactor(sizeof(pendulumsimulation_self_t));
    // Set input by default to an always absent default input.
    self->_lf_u = &self->_lf_default__u;
    // Set input by default to an always absent default input.
    self->_lf_d = &self->_lf_default__d;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = pendulumsimulationreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__reaction_1.number = 1;
    self->_lf__reaction_1.function = pendulumsimulationreaction_function_1;
    self->_lf__reaction_1.self = self;
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    self->_lf__reaction_1.STP_handler = NULL;
    self->_lf__reaction_1.name = "?";
    self->_lf__reaction_1.mode = NULL;
    self->_lf__reaction_2.number = 2;
    self->_lf__reaction_2.function = pendulumsimulationreaction_function_2;
    self->_lf__reaction_2.self = self;
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    self->_lf__reaction_2.STP_handler = NULL;
    self->_lf__reaction_2.name = "?";
    self->_lf__reaction_2.mode = NULL;
    self->_lf__t.last = NULL;
    self->_lf__t_reactions[0] = &self->_lf__reaction_0;
    self->_lf__t.reactions = &self->_lf__t_reactions[0];
    self->_lf__t.number_of_reactions = 1;
    self->_lf__t.is_timer = true;
    self->_lf__u.last = NULL;
    self->_lf__u_reactions[0] = &self->_lf__reaction_2;
    self->_lf__u.reactions = &self->_lf__u_reactions[0];
    self->_lf__u.number_of_reactions = 1;
    self->_lf__u.element_size = sizeof(double);
    self->_lf__d.last = NULL;
    self->_lf__d_reactions[0] = &self->_lf__reaction_1;
    self->_lf__d.reactions = &self->_lf__d_reactions[0];
    self->_lf__d.number_of_reactions = 1;
    self->_lf__d.element_size = sizeof(double);
    return self;
}
// =============== END reactor class PendulumSimulation
// =============== START reactor class Print
// *********** From the preamble, verbatim:
#include <math.h>
#define PI 3.14159265
double sign(double x) {
        return (x > 0.0) - (x < 0.0); 
}
double restrictAngle(double theta) {
        return((fmod(fabs(theta) + PI, 2 * PI) - PI) * sign(theta));
}
// *********** End of preamble.
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} print_control_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} print_theta_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} print_phi_t;
typedef struct {
    struct self_base_t base;
    string filename;
    FILE* file;
    print_control_t* _lf_control;
    // width of -2 indicates that it is not a multiport.
    int _lf_control_width;
    // Default input (in case it does not get connected)
    print_control_t _lf_default__control;
    print_theta_t* _lf_theta;
    // width of -2 indicates that it is not a multiport.
    int _lf_theta_width;
    // Default input (in case it does not get connected)
    print_theta_t _lf_default__theta;
    print_phi_t* _lf_phi;
    // width of -2 indicates that it is not a multiport.
    int _lf_phi_width;
    // Default input (in case it does not get connected)
    print_phi_t _lf_default__phi;
    reaction_t _lf__reaction_0;
    reaction_t _lf__reaction_1;
    reaction_t _lf__reaction_2;
    trigger_t _lf__startup;
    reaction_t* _lf__startup_reactions[1];
    trigger_t _lf__shutdown;
    reaction_t* _lf__shutdown_reactions[1];
    trigger_t _lf__control;
    reaction_t* _lf__control_reactions[1];
    trigger_t _lf__theta;
    reaction_t* _lf__theta_reactions[1];
    trigger_t _lf__phi;
    reaction_t* _lf__phi_reactions[1];
} print_self_t;
// ***** Start of method declarations.
// ***** End of method declarations.
#include "include/ctarget/set.h"
void printreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    print_self_t* self = (print_self_t*)instance_args;
    #pragma GCC diagnostic pop
    self->file = fopen(self->filename, "w");
    if(self->file == NULL) {
        lf_print_error_and_exit("Failed to open file: %s", self->filename);
    } else {
        fprintf(self->file, "Time,Control,Theta,Phi\n");
    }
        
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void printreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    print_self_t* self = (print_self_t*)instance_args;
    print_control_t* control = self->_lf_control;
    int control_width = self->_lf_control_width;
    print_theta_t* theta = self->_lf_theta;
    int theta_width = self->_lf_theta_width;
    print_phi_t* phi = self->_lf_phi;
    int phi_width = self->_lf_phi_width;
    #pragma GCC diagnostic pop
    double t = lf_time_logical_elapsed() / 1.0e9;
    fprintf(self->file,
        "%f,%f,%f,%f\n",
        t,
        control->value,
        restrictAngle(theta->value),
        restrictAngle(phi->value)
    );
        
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void printreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    print_self_t* self = (print_self_t*)instance_args;
    #pragma GCC diagnostic pop
    fclose(self->file);
        
}
#include "include/ctarget/set_undef.h"
print_self_t* new_Print() {
    print_self_t* self = (print_self_t*)_lf_new_reactor(sizeof(print_self_t));
    // Set input by default to an always absent default input.
    self->_lf_control = &self->_lf_default__control;
    // Set input by default to an always absent default input.
    self->_lf_theta = &self->_lf_default__theta;
    // Set input by default to an always absent default input.
    self->_lf_phi = &self->_lf_default__phi;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = printreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__reaction_1.number = 1;
    self->_lf__reaction_1.function = printreaction_function_1;
    self->_lf__reaction_1.self = self;
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    self->_lf__reaction_1.STP_handler = NULL;
    self->_lf__reaction_1.name = "?";
    self->_lf__reaction_1.mode = NULL;
    self->_lf__reaction_2.number = 2;
    self->_lf__reaction_2.function = printreaction_function_2;
    self->_lf__reaction_2.self = self;
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    self->_lf__reaction_2.STP_handler = NULL;
    self->_lf__reaction_2.name = "?";
    self->_lf__reaction_2.mode = NULL;
    self->_lf__startup_reactions[0] = &self->_lf__reaction_0;
    self->_lf__startup.last = NULL;
    self->_lf__startup.reactions = &self->_lf__startup_reactions[0];
    self->_lf__startup.number_of_reactions = 1;
    self->_lf__startup.is_timer = false;
    self->_lf__shutdown_reactions[0] = &self->_lf__reaction_2;
    self->_lf__shutdown.last = NULL;
    self->_lf__shutdown.reactions = &self->_lf__shutdown_reactions[0];
    self->_lf__shutdown.number_of_reactions = 1;
    self->_lf__shutdown.is_timer = false;
    self->_lf__control.last = NULL;
    self->_lf__control_reactions[0] = &self->_lf__reaction_1;
    self->_lf__control.reactions = &self->_lf__control_reactions[0];
    self->_lf__control.number_of_reactions = 1;
    self->_lf__control.element_size = sizeof(double);
    self->_lf__theta.last = NULL;
    self->_lf__theta_reactions[0] = &self->_lf__reaction_1;
    self->_lf__theta.reactions = &self->_lf__theta_reactions[0];
    self->_lf__theta.number_of_reactions = 1;
    self->_lf__theta.element_size = sizeof(double);
    self->_lf__phi.last = NULL;
    self->_lf__phi_reactions[0] = &self->_lf__reaction_1;
    self->_lf__phi.reactions = &self->_lf__phi_reactions[0];
    self->_lf__phi.number_of_reactions = 1;
    self->_lf__phi.element_size = sizeof(double);
    return self;
}
// =============== END reactor class Print
// =============== START reactor class PendulumController
// *********** From the preamble, verbatim:
#include <math.h>
    
// *********** End of preamble.
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumcontroller_theta_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumcontroller_d_theta_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumcontroller_phi_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumcontroller_d_phi_t;
typedef struct {
    double value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} pendulumcontroller_u_t;
typedef struct {
    struct self_base_t base;
    double ci1;
    double ci2;
    double ci3;
    double ci4;
    double si1;
    double si2;
    double si3;
    double si4;
    double ph2;
    double Energy;
    double Control;
    double phi_variable;
    pendulumcontroller_theta_t* _lf_theta;
    // width of -2 indicates that it is not a multiport.
    int _lf_theta_width;
    // Default input (in case it does not get connected)
    pendulumcontroller_theta_t _lf_default__theta;
    pendulumcontroller_d_theta_t* _lf_d_theta;
    // width of -2 indicates that it is not a multiport.
    int _lf_d_theta_width;
    // Default input (in case it does not get connected)
    pendulumcontroller_d_theta_t _lf_default__d_theta;
    pendulumcontroller_phi_t* _lf_phi;
    // width of -2 indicates that it is not a multiport.
    int _lf_phi_width;
    // Default input (in case it does not get connected)
    pendulumcontroller_phi_t _lf_default__phi;
    pendulumcontroller_d_phi_t* _lf_d_phi;
    // width of -2 indicates that it is not a multiport.
    int _lf_d_phi_width;
    // Default input (in case it does not get connected)
    pendulumcontroller_d_phi_t _lf_default__d_phi;
    pendulumcontroller_u_t _lf_u;
    int _lf_u_width;
    reaction_t _lf__reaction_0;
    trigger_t _lf__theta;
    reaction_t* _lf__theta_reactions[1];
    trigger_t _lf__d_theta;
    reaction_t* _lf__d_theta_reactions[1];
    trigger_t _lf__phi;
    reaction_t* _lf__phi_reactions[1];
    trigger_t _lf__d_phi;
    reaction_t* _lf__d_phi_reactions[1];
} pendulumcontroller_self_t;
// ***** Start of method declarations.
// ***** End of method declarations.
#include "include/ctarget/set.h"
void pendulumcontrollerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pendulumcontroller_self_t* self = (pendulumcontroller_self_t*)instance_args;
    pendulumcontroller_theta_t* theta = self->_lf_theta;
    int theta_width = self->_lf_theta_width;
    pendulumcontroller_d_theta_t* d_theta = self->_lf_d_theta;
    int d_theta_width = self->_lf_d_theta_width;
    pendulumcontroller_phi_t* phi = self->_lf_phi;
    int phi_width = self->_lf_phi_width;
    pendulumcontroller_d_phi_t* d_phi = self->_lf_d_phi;
    int d_phi_width = self->_lf_d_phi_width;
    pendulumcontroller_u_t* u = &self->_lf_u;
    #pragma GCC diagnostic pop
    // declare statement of 'self->Energy'
    self->Energy  = 0.5 * pow(d_theta -> value, 2) / pow(6.3, 2) + 
                    cos(theta -> value) - 1;
    
    // if absolue vaule of theta is smaller than 0.2, have to go to the 'Catch' state
    // and if larger than 0.2, then have to go to the 'SwingUp' state
    if(fabs(theta -> value) < 0.2) {
        // declare statement of 'self->Control' of 'Catch' state
        self->Control = -1 * (theta -> value * self -> ci1 + d_theta -> value * 
                        self -> ci2 + (phi -> value - self -> ph2) * self -> ci3 + 
                        d_phi -> value * self -> ci4);
    }
    else {
        // declare statement of 'self->Contol' of 'SwingUp' state
        self->Control = sign(self->Energy) * sign(d_theta -> value * 
                        cos(theta -> value)) * fmin(fabs(0.5 * self->Energy), 0.5);
    }
    
    // if absolute vaule of d_phi is smaller than 0.05, have to go to the 'Stabilize' state
    if(fabs(d_phi -> value) < 0.05) {
        self->phi_variable = phi -> value;
        self->Control = -1 * (theta -> value * self -> si1 + d_theta -> value * 
                        self -> si2 + (phi -> value - self->phi_variable) * 
                        self -> si3 + d_phi -> value * self -> si4);
    }
    
    // Continuously set the output 'u' as a 'self->Control' value
    lf_set(u, self->Control);
}
#include "include/ctarget/set_undef.h"
pendulumcontroller_self_t* new_PendulumController() {
    pendulumcontroller_self_t* self = (pendulumcontroller_self_t*)_lf_new_reactor(sizeof(pendulumcontroller_self_t));
    // Set input by default to an always absent default input.
    self->_lf_theta = &self->_lf_default__theta;
    // Set input by default to an always absent default input.
    self->_lf_d_theta = &self->_lf_default__d_theta;
    // Set input by default to an always absent default input.
    self->_lf_phi = &self->_lf_default__phi;
    // Set input by default to an always absent default input.
    self->_lf_d_phi = &self->_lf_default__d_phi;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = pendulumcontrollerreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__theta.last = NULL;
    self->_lf__theta_reactions[0] = &self->_lf__reaction_0;
    self->_lf__theta.reactions = &self->_lf__theta_reactions[0];
    self->_lf__theta.number_of_reactions = 1;
    self->_lf__theta.element_size = sizeof(double);
    self->_lf__d_theta.last = NULL;
    self->_lf__d_theta_reactions[0] = &self->_lf__reaction_0;
    self->_lf__d_theta.reactions = &self->_lf__d_theta_reactions[0];
    self->_lf__d_theta.number_of_reactions = 1;
    self->_lf__d_theta.element_size = sizeof(double);
    self->_lf__phi.last = NULL;
    self->_lf__phi_reactions[0] = &self->_lf__reaction_0;
    self->_lf__phi.reactions = &self->_lf__phi_reactions[0];
    self->_lf__phi.number_of_reactions = 1;
    self->_lf__phi.element_size = sizeof(double);
    self->_lf__d_phi.last = NULL;
    self->_lf__d_phi_reactions[0] = &self->_lf__reaction_0;
    self->_lf__d_phi.reactions = &self->_lf__d_phi_reactions[0];
    self->_lf__d_phi.number_of_reactions = 1;
    self->_lf__d_phi.element_size = sizeof(double);
    return self;
}
// =============== END reactor class PendulumController
// =============== START reactor class MainPendulum
typedef struct {
    struct self_base_t base;
} mainpendulum_self_t;
// ***** Start of method declarations.
// ***** End of method declarations.
mainpendulum_self_t* new_MainPendulum() {
    mainpendulum_self_t* self = (mainpendulum_self_t*)_lf_new_reactor(sizeof(mainpendulum_self_t));
    return self;
}
// =============== END reactor class MainPendulum
// Array of pointers to timer triggers to be scheduled in _lf_initialize_timers().
trigger_t* _lf_timer_triggers[1];
int _lf_timer_triggers_size = 1;
// Array of pointers to startup triggers.
reaction_t* _lf_startup_reactions[1];
int _lf_startup_reactions_size = 1;
// Array of pointers to shutdown triggers.
reaction_t* _lf_shutdown_reactions[1];
int _lf_shutdown_reactions_size = 1;
// Array of pointers to reset triggers.
reaction_t** _lf_reset_reactions = NULL;
int _lf_reset_reactions_size = 0;
trigger_t* _lf_action_for_port(int port_id) {
        return NULL;
}
void _lf_initialize_trigger_objects() {
    // Initialize the _lf_clock
    lf_initialize_clock();
    // Create the array that will contain pointers to is_present fields to reset on each step.
    _lf_is_present_fields_size = 5;
    _lf_is_present_fields = (bool**)calloc(5, sizeof(bool*));
    if (_lf_is_present_fields == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated = (bool**)calloc(5, sizeof(bool*));
    if (_lf_is_present_fields_abbreviated == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated_size = 0;
    int _lf_startup_reactions_count = 0;
    int _lf_shutdown_reactions_count = 0;
    int _lf_reset_reactions_count = 0;
    int _lf_timer_triggers_count = 0;
    int _lf_tokens_with_ref_count_count = 0;
    mainpendulum_self_t* mainpendulum_self[1];
    pendulumsimulation_self_t* mainpendulum_p1_self[1];
    print_self_t* mainpendulum_p2_self[1];
    pendulumcontroller_self_t* mainpendulum_p3_self[1];
    // ***** Start initializing MainPendulum of class MainPendulum
    mainpendulum_self[0] = new_MainPendulum();
    int bank_index = 0;
    {
        // ***** Start initializing MainPendulum.P1 of class PendulumSimulation
        mainpendulum_p1_self[0] = new_PendulumSimulation();
        int bank_index = 0;
        mainpendulum_p1_self[0]->initial_theta = -3.14159;
        mainpendulum_p1_self[0]->sample_period = MSEC(5);
        mainpendulum_p1_self[0]->g = 9.81;
        mainpendulum_p1_self[0]->alpha = 0.00260569;
        mainpendulum_p1_self[0]->beta = 0.05165675;
        mainpendulum_p1_self[0]->gamma = 9.7055e-4;
        mainpendulum_p1_self[0]->epsilon = 0.08103060;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_theta_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_d_theta_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_phi_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_d_phi_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_u_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p1_self[0]->_lf_d_width = -2;
        { // For scoping
            static double _initial[4] = {0.0, 0.0, 0.0, 0.0};
            mainpendulum_p1_self[0]->x = _initial;
        } // End scoping.
        { // For scoping
            static bool _initial = true;
            mainpendulum_p1_self[0]->first = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = 0.0;
            mainpendulum_p1_self[0]->latest_u = _initial;
        } // End scoping.
        // Initializing timer MainPendulum.P1.t.
        mainpendulum_p1_self[0]->_lf__t.offset = 0;
        mainpendulum_p1_self[0]->_lf__t.period = MSEC(5);
        _lf_timer_triggers[_lf_timer_triggers_count++] = &mainpendulum_p1_self[0]->_lf__t;
        mainpendulum_p1_self[0]->_lf__t.mode = NULL;
        mainpendulum_p1_self[0]->_lf__reaction_0.deadline = NEVER;
        mainpendulum_p1_self[0]->_lf__reaction_1.deadline = NEVER;
        mainpendulum_p1_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing MainPendulum.P1
    }
    {
        // ***** Start initializing MainPendulum.P2 of class Print
        mainpendulum_p2_self[0] = new_Print();
        int bank_index = 0;
        mainpendulum_p2_self[0]->filename = "/home/plutonh/project/EmbeddedSystemsLab/FurutaPendulum/pendulum.csv";
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p2_self[0]->_lf_control_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p2_self[0]->_lf_theta_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p2_self[0]->_lf_phi_width = -2;
        _lf_startup_reactions[_lf_startup_reactions_count++] = &mainpendulum_p2_self[0]->_lf__reaction_0;
        _lf_shutdown_reactions[_lf_shutdown_reactions_count++] = &mainpendulum_p2_self[0]->_lf__reaction_2;
        { // For scoping
            static FILE* _initial = NULL;
            mainpendulum_p2_self[0]->file = _initial;
        } // End scoping.
        mainpendulum_p2_self[0]->_lf__reaction_0.deadline = NEVER;
        mainpendulum_p2_self[0]->_lf__reaction_1.deadline = NEVER;
        mainpendulum_p2_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing MainPendulum.P2
    }
    {
        // ***** Start initializing MainPendulum.P3 of class PendulumController
        mainpendulum_p3_self[0] = new_PendulumController();
        int bank_index = 0;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p3_self[0]->_lf_u_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p3_self[0]->_lf_theta_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p3_self[0]->_lf_d_theta_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p3_self[0]->_lf_phi_width = -2;
        // width of -2 indicates that it is not a multiport.
        mainpendulum_p3_self[0]->_lf_d_phi_width = -2;
        { // For scoping
            static double _initial = -1.04945717118225;
            mainpendulum_p3_self[0]->ci1 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.20432286791216;
            mainpendulum_p3_self[0]->ci2 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.00735846749875;
            mainpendulum_p3_self[0]->ci3 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.00735846749875;
            mainpendulum_p3_self[0]->ci4 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -1.70871686211144;
            mainpendulum_p3_self[0]->si1 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.30395427746831;
            mainpendulum_p3_self[0]->si2 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.03254225945714;
            mainpendulum_p3_self[0]->si3 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -0.05808270221773;
            mainpendulum_p3_self[0]->si4 = _initial;
        } // End scoping.
        { // For scoping
            static double _initial = -7.0124562;
            mainpendulum_p3_self[0]->ph2 = _initial;
        } // End scoping.
        mainpendulum_p3_self[0]->_lf__reaction_0.deadline = NEVER;
        //***** End initializing MainPendulum.P3
    }
    //***** End initializing MainPendulum
    // **** Start deferred initialize for MainPendulum
    {
        // **** Start deferred initialize for MainPendulum.P1
        {
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of MainPendulum.P1.
            mainpendulum_p1_self[0]->_lf__reaction_0.num_outputs = 4;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            mainpendulum_p1_self[0]->_lf__reaction_0.triggers = (trigger_t***)_lf_allocate(
                    4, sizeof(trigger_t**),
                    &mainpendulum_p1_self[0]->base.allocations);
            mainpendulum_p1_self[0]->_lf__reaction_0.triggered_sizes = (int*)_lf_allocate(
                    4, sizeof(int),
                    &mainpendulum_p1_self[0]->base.allocations);
            mainpendulum_p1_self[0]->_lf__reaction_0.output_produced = (bool**)_lf_allocate(
                    4, sizeof(bool*),
                    &mainpendulum_p1_self[0]->base.allocations);
            {
                int count = 0;
                {
                    mainpendulum_p1_self[0]->_lf__reaction_0.output_produced[count++] = &mainpendulum_p1_self[0]->_lf_theta.is_present;
                }
                {
                    mainpendulum_p1_self[0]->_lf__reaction_0.output_produced[count++] = &mainpendulum_p1_self[0]->_lf_d_theta.is_present;
                }
                {
                    mainpendulum_p1_self[0]->_lf__reaction_0.output_produced[count++] = &mainpendulum_p1_self[0]->_lf_phi.is_present;
                }
                {
                    mainpendulum_p1_self[0]->_lf__reaction_0.output_produced[count++] = &mainpendulum_p1_self[0]->_lf_d_phi.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of MainPendulum.P1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of MainPendulum.P1.
            mainpendulum_p1_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 1 of MainPendulum.P1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of MainPendulum.P1.
            mainpendulum_p1_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 2 of MainPendulum.P1
        }
        // **** End of deferred initialize for MainPendulum.P1
        // **** Start deferred initialize for MainPendulum.P2
        {
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of MainPendulum.P2.
            mainpendulum_p2_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 0 of MainPendulum.P2
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of MainPendulum.P2.
            mainpendulum_p2_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 1 of MainPendulum.P2
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of MainPendulum.P2.
            mainpendulum_p2_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 2 of MainPendulum.P2
        }
        // **** End of deferred initialize for MainPendulum.P2
        // **** Start deferred initialize for MainPendulum.P3
        {
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of MainPendulum.P3.
            mainpendulum_p3_self[0]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            mainpendulum_p3_self[0]->_lf__reaction_0.triggers = (trigger_t***)_lf_allocate(
                    1, sizeof(trigger_t**),
                    &mainpendulum_p3_self[0]->base.allocations);
            mainpendulum_p3_self[0]->_lf__reaction_0.triggered_sizes = (int*)_lf_allocate(
                    1, sizeof(int),
                    &mainpendulum_p3_self[0]->base.allocations);
            mainpendulum_p3_self[0]->_lf__reaction_0.output_produced = (bool**)_lf_allocate(
                    1, sizeof(bool*),
                    &mainpendulum_p3_self[0]->base.allocations);
            {
                int count = 0;
                {
                    mainpendulum_p3_self[0]->_lf__reaction_0.output_produced[count++] = &mainpendulum_p3_self[0]->_lf_u.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of MainPendulum.P3
        }
        // **** End of deferred initialize for MainPendulum.P3
    }
    // **** End of deferred initialize for MainPendulum
    // **** Start non-nested deferred initialize for MainPendulum
    // **** Start non-nested deferred initialize for MainPendulum.P1
    // For reference counting, set num_destinations for port MainPendulum.P1.theta.
    // Iterate over range MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        mainpendulum_p1_self[src_runtime]->_lf_theta.num_destinations = 2;
    }
    // For reference counting, set num_destinations for port MainPendulum.P1.d_theta.
    // Iterate over range MainPendulum.P1.d_theta(0,1)->[MainPendulum.P3.d_theta(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        mainpendulum_p1_self[src_runtime]->_lf_d_theta.num_destinations = 1;
    }
    // For reference counting, set num_destinations for port MainPendulum.P1.phi.
    // Iterate over range MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        mainpendulum_p1_self[src_runtime]->_lf_phi.num_destinations = 2;
    }
    // For reference counting, set num_destinations for port MainPendulum.P1.d_phi.
    // Iterate over range MainPendulum.P1.d_phi(0,1)->[MainPendulum.P3.d_phi(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        mainpendulum_p1_self[src_runtime]->_lf_d_phi.num_destinations = 1;
    }
    {
        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 0 of MainPendulum.P1 triggers 2 downstream reactions
            // through port MainPendulum.P1.theta.
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 2;
            // For reaction 0 of MainPendulum.P1, allocate an
            // array of trigger pointers for downstream reactions through port MainPendulum.P1.theta
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    2, sizeof(trigger_t*),
                    &mainpendulum_p1_self[src_runtime]->base.allocations); 
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        // Iterate over range MainPendulum.P1.d_theta(0,1)->[MainPendulum.P3.d_theta(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 0 of MainPendulum.P1 triggers 1 downstream reactions
            // through port MainPendulum.P1.d_theta.
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
            // For reaction 0 of MainPendulum.P1, allocate an
            // array of trigger pointers for downstream reactions through port MainPendulum.P1.d_theta
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    1, sizeof(trigger_t*),
                    &mainpendulum_p1_self[src_runtime]->base.allocations); 
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        // Iterate over range MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 0 of MainPendulum.P1 triggers 2 downstream reactions
            // through port MainPendulum.P1.phi.
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 2;
            // For reaction 0 of MainPendulum.P1, allocate an
            // array of trigger pointers for downstream reactions through port MainPendulum.P1.phi
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    2, sizeof(trigger_t*),
                    &mainpendulum_p1_self[src_runtime]->base.allocations); 
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        // Iterate over range MainPendulum.P1.d_phi(0,1)->[MainPendulum.P3.d_phi(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 0 of MainPendulum.P1 triggers 1 downstream reactions
            // through port MainPendulum.P1.d_phi.
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
            // For reaction 0 of MainPendulum.P1, allocate an
            // array of trigger pointers for downstream reactions through port MainPendulum.P1.d_phi
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    1, sizeof(trigger_t*),
                    &mainpendulum_p1_self[src_runtime]->base.allocations); 
            mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
        // Iterate over ranges MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] and MainPendulum.P2.theta(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P2.theta(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P2.theta's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &mainpendulum_p2_self[dst_runtime]->_lf__theta;
            }
        }
        // Iterate over ranges MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] and MainPendulum.P3.theta(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P3.theta(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P3.theta's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][1] = &mainpendulum_p3_self[dst_runtime]->_lf__theta;
            }
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 1;
        // Iterate over ranges MainPendulum.P1.d_theta(0,1)->[MainPendulum.P3.d_theta(0,1)] and MainPendulum.P3.d_theta(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P3.d_theta(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P3.d_theta's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &mainpendulum_p3_self[dst_runtime]->_lf__d_theta;
            }
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 2;
        // Iterate over ranges MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] and MainPendulum.P2.phi(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P2.phi(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P2.phi's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &mainpendulum_p2_self[dst_runtime]->_lf__phi;
            }
        }
        // Iterate over ranges MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] and MainPendulum.P3.phi(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P3.phi(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P3.phi's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][1] = &mainpendulum_p3_self[dst_runtime]->_lf__phi;
            }
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 3;
        // Iterate over ranges MainPendulum.P1.d_phi(0,1)->[MainPendulum.P3.d_phi(0,1)] and MainPendulum.P3.d_phi(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P3.d_phi(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P3.d_phi's trigger struct.
                mainpendulum_p1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &mainpendulum_p3_self[dst_runtime]->_lf__d_phi;
            }
        }
    }
    // **** End of non-nested deferred initialize for MainPendulum.P1
    // **** Start non-nested deferred initialize for MainPendulum.P2
    // **** End of non-nested deferred initialize for MainPendulum.P2
    // **** Start non-nested deferred initialize for MainPendulum.P3
    // For reference counting, set num_destinations for port MainPendulum.P3.u.
    // Iterate over range MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        mainpendulum_p3_self[src_runtime]->_lf_u.num_destinations = 2;
    }
    {
        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 0 of MainPendulum.P3 triggers 2 downstream reactions
            // through port MainPendulum.P3.u.
            mainpendulum_p3_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 2;
            // For reaction 0 of MainPendulum.P3, allocate an
            // array of trigger pointers for downstream reactions through port MainPendulum.P3.u
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    2, sizeof(trigger_t*),
                    &mainpendulum_p3_self[src_runtime]->base.allocations); 
            mainpendulum_p3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
        // Iterate over ranges MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] and MainPendulum.P2.control(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P2.control(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P2.control's trigger struct.
                mainpendulum_p3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &mainpendulum_p2_self[dst_runtime]->_lf__control;
            }
        }
        // Iterate over ranges MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] and MainPendulum.P1.u(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range MainPendulum.P1.u(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port MainPendulum.P1.u's trigger struct.
                mainpendulum_p3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][1] = &mainpendulum_p1_self[dst_runtime]->_lf__u;
            }
        }
    }
    // **** End of non-nested deferred initialize for MainPendulum.P3
    // **** End of non-nested deferred initialize for MainPendulum
    // Connect inputs and outputs for reactor MainPendulum.
    // Connect inputs and outputs for reactor MainPendulum.P1.
    // Connect MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] to port MainPendulum.P2.theta(0,1)
    // Iterate over ranges MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] and MainPendulum.P2.theta(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P2.theta(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p2_self[dst_runtime]->_lf_theta = (print_theta_t*)&mainpendulum_p1_self[src_runtime]->_lf_theta;
        }
    }
    // Connect MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] to port MainPendulum.P3.theta(0,1)
    // Iterate over ranges MainPendulum.P1.theta(0,1)->[MainPendulum.P2.theta(0,1), MainPendulum.P3.theta(0,1)] and MainPendulum.P3.theta(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P3.theta(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p3_self[dst_runtime]->_lf_theta = (pendulumcontroller_theta_t*)&mainpendulum_p1_self[src_runtime]->_lf_theta;
        }
    }
    // Connect MainPendulum.P1.d_theta(0,1)->[MainPendulum.P3.d_theta(0,1)] to port MainPendulum.P3.d_theta(0,1)
    // Iterate over ranges MainPendulum.P1.d_theta(0,1)->[MainPendulum.P3.d_theta(0,1)] and MainPendulum.P3.d_theta(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P3.d_theta(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p3_self[dst_runtime]->_lf_d_theta = (pendulumcontroller_d_theta_t*)&mainpendulum_p1_self[src_runtime]->_lf_d_theta;
        }
    }
    // Connect MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] to port MainPendulum.P2.phi(0,1)
    // Iterate over ranges MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] and MainPendulum.P2.phi(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P2.phi(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p2_self[dst_runtime]->_lf_phi = (print_phi_t*)&mainpendulum_p1_self[src_runtime]->_lf_phi;
        }
    }
    // Connect MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] to port MainPendulum.P3.phi(0,1)
    // Iterate over ranges MainPendulum.P1.phi(0,1)->[MainPendulum.P2.phi(0,1), MainPendulum.P3.phi(0,1)] and MainPendulum.P3.phi(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P3.phi(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p3_self[dst_runtime]->_lf_phi = (pendulumcontroller_phi_t*)&mainpendulum_p1_self[src_runtime]->_lf_phi;
        }
    }
    // Connect MainPendulum.P1.d_phi(0,1)->[MainPendulum.P3.d_phi(0,1)] to port MainPendulum.P3.d_phi(0,1)
    // Iterate over ranges MainPendulum.P1.d_phi(0,1)->[MainPendulum.P3.d_phi(0,1)] and MainPendulum.P3.d_phi(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P3.d_phi(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p3_self[dst_runtime]->_lf_d_phi = (pendulumcontroller_d_phi_t*)&mainpendulum_p1_self[src_runtime]->_lf_d_phi;
        }
    }
    // Connect inputs and outputs for reactor MainPendulum.P2.
    // Connect inputs and outputs for reactor MainPendulum.P3.
    // Connect MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] to port MainPendulum.P2.control(0,1)
    // Iterate over ranges MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] and MainPendulum.P2.control(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P2.control(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p2_self[dst_runtime]->_lf_control = (print_control_t*)&mainpendulum_p3_self[src_runtime]->_lf_u;
        }
    }
    // Connect MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] to port MainPendulum.P1.u(0,1)
    // Iterate over ranges MainPendulum.P3.u(0,1)->[MainPendulum.P2.control(0,1), MainPendulum.P1.u(0,1)] and MainPendulum.P1.u(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range MainPendulum.P1.u(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            mainpendulum_p1_self[dst_runtime]->_lf_u = (pendulumsimulation_u_t*)&mainpendulum_p3_self[src_runtime]->_lf_u;
        }
    }
    {
    }
    {
    }
    {
    }
    {
        int count = 0;
        {
            // Add port MainPendulum.P1.theta to array of is_present fields.
            _lf_is_present_fields[0 + count] = &mainpendulum_p1_self[0]->_lf_theta.is_present;
            count++;
            // Add port MainPendulum.P1.d_theta to array of is_present fields.
            _lf_is_present_fields[0 + count] = &mainpendulum_p1_self[0]->_lf_d_theta.is_present;
            count++;
            // Add port MainPendulum.P1.phi to array of is_present fields.
            _lf_is_present_fields[0 + count] = &mainpendulum_p1_self[0]->_lf_phi.is_present;
            count++;
            // Add port MainPendulum.P1.d_phi to array of is_present fields.
            _lf_is_present_fields[0 + count] = &mainpendulum_p1_self[0]->_lf_d_phi.is_present;
            count++;
        }
    }
    {
        int count = 0;
        {
            // Add port MainPendulum.P3.u to array of is_present fields.
            _lf_is_present_fields[4 + count] = &mainpendulum_p3_self[0]->_lf_u.is_present;
            count++;
        }
    }
    // Set reaction priorities for ReactorInstance MainPendulum
    {
        // Set reaction priorities for ReactorInstance MainPendulum.P1
        {
            mainpendulum_p1_self[0]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p1_self[0]->_lf__reaction_0.index = 0x7fffffffffff0000LL;
            mainpendulum_p1_self[0]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 1 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p1_self[0]->_lf__reaction_1.index = 0x7fffffffffff0001LL;
            mainpendulum_p1_self[0]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p1_self[0]->_lf__reaction_2.index = 0x7fffffffffff0002LL;
        }
        // Set reaction priorities for ReactorInstance MainPendulum.P2
        {
            mainpendulum_p2_self[0]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p2_self[0]->_lf__reaction_0.index = 0x7fffffffffff0000LL;
            mainpendulum_p2_self[0]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p2_self[0]->_lf__reaction_1.index = 0x7fffffffffff0002LL;
            mainpendulum_p2_self[0]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 3 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p2_self[0]->_lf__reaction_2.index = 0x7fffffffffff0003LL;
        }
        // Set reaction priorities for ReactorInstance MainPendulum.P3
        {
            mainpendulum_p3_self[0]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 1 and 
            // deadline 140737488355327 shifted left 16 bits.
            mainpendulum_p3_self[0]->_lf__reaction_0.index = 0x7fffffffffff0001LL;
        }
    }
    // Initialize the scheduler
    size_t num_reactions_per_level[4] = 
        {2, 2, 2, 1};
    sched_params_t sched_params = (sched_params_t) {
                            .num_reactions_per_level = &num_reactions_per_level[0],
                            .num_reactions_per_level_size = (size_t) 4};
    lf_sched_init(
        (size_t)_lf_number_of_workers,
        &sched_params
    );
}
void _lf_trigger_startup_reactions() {
    for (int i = 0; i < _lf_startup_reactions_size; i++) {
        if (_lf_startup_reactions[i] != NULL) {
            _lf_trigger_reaction(_lf_startup_reactions[i], -1);
        }
    }
}
void _lf_initialize_timers() {
    for (int i = 0; i < _lf_timer_triggers_size; i++) {
        if (_lf_timer_triggers[i] != NULL) {
            _lf_initialize_timer(_lf_timer_triggers[i]);
        }
    }
}
void logical_tag_complete(tag_t tag_to_send) {
}
bool _lf_trigger_shutdown_reactions() {
    for (int i = 0; i < _lf_shutdown_reactions_size; i++) {
        if (_lf_shutdown_reactions[i] != NULL) {
            _lf_trigger_reaction(_lf_shutdown_reactions[i], -1);
        }
    }
    return true;
}
void terminate_execution() {}
